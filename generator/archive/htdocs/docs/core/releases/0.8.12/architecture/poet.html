

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PoET 1.0 Specification &mdash; Sawtooth v0.8.12 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Sawtooth v0.8.12 documentation" href="../index.html"/>
        <link rel="up" title="Architecture" href="../architecture.html"/>
        <link rel="next" title="Validator Network" href="validator_network.html"/>
        <link rel="prev" title="REST API" href="rest_api.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../contents.html" class="icon icon-home"> Sawtooth
          

          
          </a>

          
            
            
              <div class="version">
                v0.8.12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../architecture.html">Architecture</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="global_state.html">Global State</a></li>
<li class="toctree-l2"><a class="reference internal" href="transactions_and_batches.html">Transactions and Batches!</a></li>
<li class="toctree-l2"><a class="reference internal" href="journal.html">Journal</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheduling.html">Transaction Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="rest_api.html">REST API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">PoET 1.0 Specification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#p2p-poet-sgx-enclave-specifications">P2P PoET SGX Enclave Specifications</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generatesignupdata-opkhash"><code class="docutils literal"><span class="pre">generateSignUpData(OPKhash)</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#unsealsignupdata-sealedsignupdata"><code class="docutils literal"><span class="pre">unsealSignUpData(sealedSignUpData)</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#createwaittimer-localmean-waitcertid-n"><code class="docutils literal"><span class="pre">createWaitTimer(localMean,</span> <span class="pre">WaitCertId_n)</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#createwaitcertificate-blockdigest"><code class="docutils literal"><span class="pre">createWaitCertificate(blockDigest)</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#population-size-and-local-mean-computation">Population Size and Local Mean Computation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#z-test">z-test</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="validator_network.html">Validator Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="permissioning_requirement.html">Permissioning Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="injecting_batches_block_validation_rules.html">Injecting Batches and On-Chain Block Validation Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="events_and_transactions_receipts.html">Events and Transaction Receipts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../app_developers_guide.html">Application Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solidity_developers_guide.html">Solidity Developers Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core_developers_guide.html">Core Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sysadmin_guide.html">System Administrator&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rest_api.html">REST API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cli.html">CLI Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../transaction_family_specifications.html">Transaction Family Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">Sawtooth</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="../architecture.html">Architecture</a> &raquo;</li>
        
      <li>PoET 1.0 Specification</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/architecture/poet.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="poet-1-0-specification">
<h1>PoET 1.0 Specification<a class="headerlink" href="#poet-1-0-specification" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Proof-of-Elapsed-Time or PoET Consensus method offers a solution to the
Byzantine Generals Problem that utilizes a “trusted execution environment” to
improve on the efficiency of present solutions such as Proof-of-Work. The
initial reference implementation of PoET released to Hyperledger was written for
an abstract TEE to keep it flexible to any TEE implementation. This
specification defines a concrete implementation for SGX. The following
presentation assumes the use of Intel SGX as the trusted execution environment.</p>
<p>At a high-level, PoET stochastically elects individual peers to execute requests
at a given target rate. Individual peers sample an exponentially distributed
random variable and wait for an amount of time dictated by the sample. The peer
with the smallest sample wins the election. Cheating is prevented through the
use of a trusted execution environment, identity verification and blacklisting
based on asymmetric key cryptography, and an additional set of election
policies.</p>
</div>
<div class="section" id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>The following terms are used throughout the PoET spec and are defined here for
reference.</p>
<dl class="docutils">
<dt>Enclave</dt>
<dd><p class="first">A protected area in an application’s address space which provides
confidentiality and integrity even in the presence of privileged malware.</p>
<p class="last">The term can also be used to refer to a specific enclave that has been
initialized with a specific code and data.</p>
</dd>
<dt>Basename</dt>
<dd>A service provider base name. In our context the service provider
entity is the distributed ledger network. Each distinct network should have
its own Basename and Service Provider ID (see EPID and IAS specifications).</dd>
<dt>EPID</dt>
<dd>An anonymous credential system. See E. Brickell and Jiangtao Li: “Enhanced
Privacy ID from Bilinear Pairing for Hardware Authentication and Attestation”.
IEEE International Conference on Social Computing / IEEE International
Converence on Privacy, Security, Risk and Trust. 2010.</dd>
<dt>EPID Pseudonym</dt>
<dd>Pseudonym of an SGX platform used in linkable quotes.  It is
part of the IAS attestation response according to IAS API specifications. It
is computed as a function of the service Basename (validator network in our
case) and the device&#8217;s EPID private key.</dd>
<dt>PPK, PSK</dt>
<dd>PoET ECC public and private key created by the PoET enclave.</dd>
<dt>IAS Report Key</dt>
<dd>IAS public key used to sign attestation reports as specified
in the current IAS API Guide.</dd>
<dt>PSEmanifest</dt>
<dd>Platform Services Enclave manifest, it is part of an SGX quote
for enclaves using Platform Services like Trusted Time and Monotonic
Counters.</dd>
<dt>AEP</dt>
<dd>Attestation evidence payload sent to IAS (see IAS API specifications).
Contains JSON encodings of the quote, an optional PSEmanifest and an optional
nonce.</dd>
<dt>AVR</dt>
<dd>Attestation verification report, the response to a quote attestation
request from the IAS. It is verified with the IAS Report Key. It contains
a copy of the input AEP.</dd>
<dt><img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/></dt>
<dd>The <img class="math" src="../_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/>-th or most recent WaitCertificate digest. We
assume <img class="math" src="../_images/math/84ffcb98787b067c9a33cf362112804d24428ce7.png" alt="n &gt;= 0"/> represents the current number of blocks in the ledger.
WaitCertId is a function of the contents of the Wait Certificate. For
instance the SHA256 digest of the WaitCertificate ECDSA signature.</dd>
<dt>OPK, OSK</dt>
<dd>Originator ECDSA public and private key. These are the higher level
ECDSA keys a validator uses to sign messages.</dd>
<dt>OPKhash</dt>
<dd>SHA256 digest of OPK</dd>
<dt>blockDigest</dt>
<dd>ECDSA signature with OSK of SHA256 digest of transaction block
that the validator wants to commit.</dd>
<dt>localMean</dt>
<dd>Estimated wait time local mean.</dd>
<dt>MCID</dt>
<dd>SGX Monotonic Counter identifier.</dd>
<dt>SealKey</dt>
<dd>The SGX enclave Seal Key. It is used by the SGX <code class="docutils literal"><span class="pre">sgx_seal_data()</span></code>
and <code class="docutils literal"><span class="pre">sgx_unseal_data()</span></code> functions.</dd>
<dt>PoetSealKey</dt>
<dd>The Poet SGX enclave Seal Key. It must be obtained through the
SGX SDK <code class="docutils literal"><span class="pre">`sgx_get_key()</span></code> function passing a fixed 32 byte constant as
<code class="docutils literal"><span class="pre">key_id</span></code> argument.</dd>
<dt>PoET_MRENCLAVE</dt>
<dd>Public MRENCLAVE (see SGX SDK documentation) value of valid
PoET SGX enclave.</dd>
<dt><img class="math" src="../_images/math/7b139e757435686e4e7e9c96ba40f18ca544455e.png" alt="T_{WT}"/></dt>
<dd>WaitTimer timeout in seconds. A validator has at most <img class="math" src="../_images/math/7b139e757435686e4e7e9c96ba40f18ca544455e.png" alt="T_{WT}"/>
seconds to consume a WaitTimer, namely obtain a WaitCertificate on it after
the WaitTimer itself has expired.</dd>
<dt><img class="math" src="../_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"/></dt>
<dd>Number of blocks a validator can commit before having to sign-up with
a fresh PPK.</dd>
<dt><img class="math" src="../_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"/></dt>
<dd>The &#8220;sign-up delay&#8221;, i.e., number of blocks a validator has to wait after
sign-up before starting to participate in elections.</dd>
<dt>minDuration</dt>
<dd>Minimum duration for a WaitTimer.</dd>
</dl>
</div>
<div class="section" id="p2p-poet-sgx-enclave-specifications">
<h2>P2P PoET SGX Enclave Specifications<a class="headerlink" href="#p2p-poet-sgx-enclave-specifications" title="Permalink to this headline">¶</a></h2>
<p>The P2P PoET SGX enclave uses the following data structures:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>WaitTimer {
  double requestTime
  double duration
  byte[32] WaitCertId:sub:`n`
  double localMean
}

WaitCertificate {
  WaitTimer waitTimer
  byte[32] nonce
  byte[] blockDigest
}
</pre></div>
</div>
<p>It uses the following global variables:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">WaitTimer</span> <span class="n">activeWT</span> <span class="c1"># The unique active WaitTimer object</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">PPK</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">PSK</span>
<span class="n">MCID</span> <span class="c1"># SGX Monotonic Counter Identifier</span>
</pre></div>
</div>
<p>It exports the following functions:</p>
<div class="section" id="generatesignupdata-opkhash">
<h3><code class="docutils literal"><span class="pre">generateSignUpData(OPKhash)</span></code><a class="headerlink" href="#generatesignupdata-opkhash" title="Permalink to this headline">¶</a></h3>
<p><strong>Returns</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">byte</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>  <span class="n">PPK</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">432</span><span class="p">]</span> <span class="n">report</span> <span class="c1"># SGX Report Data Structure</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="n">PSEmanifest</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">672</span><span class="p">]</span> <span class="n">sealedSignUpData</span> <span class="c1"># (PPK, PSK, MCID) tuple encrypted with SealKey</span>
</pre></div>
</div>
<p><strong>**Parameters**</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">byte</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">OPKhash</span> <span class="c1"># SHA256 digest of OPK</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<ol class="arabic simple">
<li>Generate fresh ECC keypair (PPK, PSK)</li>
<li>Create monotonic counter and save its identifier as MCID.</li>
<li>Use the SGX <code class="docutils literal"><span class="pre">sgx_seal_data()</span></code> function to encrypt (PPK, PSK, MCID) with
SealKey (using MRENCLAVE policy)
<img class="math" src="../_images/math/ac2ba10d91488630ce9d97ec714bfeb98b87f14b.png" alt="sealedSignupData = \textnormal{AES-GCM}_{SealKey} (PPK | PSK | MCID)"/></li>
<li>Create SGX enclave report, store <code class="docutils literal"><span class="pre">SHA256(OPKhash|PPK)</span></code> in <code class="docutils literal"><span class="pre">report_data</span></code>
field.</li>
<li>Get SGX PSE manifest: PSEManifest.</li>
<li>Save (PPK, PSK, MCID) as global variables within the enclave.</li>
<li>Set active WaitTimer instance activeWT to NULL.</li>
<li>Return (PPK, report, PSEmanifest, sealedSignUpData).</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Implementation Note:</strong> Normally there is a maximum number of monotonic
counters that can be created. One way to deal with this limitation is to
destroy a previously created monotonic counter if this is not the first time
the generateSignupData function was called.</p>
</div>
</div>
<div class="section" id="unsealsignupdata-sealedsignupdata">
<h3><code class="docutils literal"><span class="pre">unsealSignUpData(sealedSignUpData)</span></code><a class="headerlink" href="#unsealsignupdata-sealedsignupdata" title="Permalink to this headline">¶</a></h3>
<p><strong>Returns</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">byte</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">PPK</span>
</pre></div>
</div>
<p><strong>Parameters</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">byte</span><span class="p">[</span><span class="mi">672</span><span class="p">]</span> <span class="n">sealedSignUpData</span> <span class="c1"># (PPK, PSK, MCID) tuple encrypted with SealKey</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<ol class="arabic simple">
<li>Use the <code class="docutils literal"><span class="pre">sgx_unseal_data()</span></code> function to decrypt sealedSignUpData into (PPK,
PSK, MCID) with SealKey (using MRENCLAVE policy).</li>
<li>Save (PPK, PSK, MCID) as global variables within the enclave.</li>
<li>Set global active WaitTimer instance activeWT to NULL.</li>
<li>Return PPK</li>
</ol>
</div>
<div class="section" id="createwaittimer-localmean-waitcertid-n">
<h3><code class="docutils literal"><span class="pre">createWaitTimer(localMean,</span> <span class="pre">WaitCertId_n)</span></code><a class="headerlink" href="#createwaittimer-localmean-waitcertid-n" title="Permalink to this headline">¶</a></h3>
<p><strong>Returns</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">WaitTimer</span> <span class="n">waitTimer</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">signature</span> <span class="c1"># ECDSA PSK signature of waitTimer</span>
</pre></div>
</div>
<p><strong>Parameters</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">localMean</span> <span class="c1"># Estimated wait time local mean</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="n">WaitCertId_n</span> <span class="c1"># SHA256 digest of WaitCertificate owner&#39;s ECDSA</span>
                      <span class="c1"># signature</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<ol class="arabic simple">
<li>Increment monotonic counter MCID and store value in global variable
counterValue.</li>
<li>Compute <img class="math" src="../_images/math/e3b146b3e1d0fe338a7d0295fd3f08e79bdd3050.png" alt="tag = \textnormal{AES-CMAC}_{PoetSealKey} (WaitCertId_{n})"/>.</li>
<li>Convert lowest 64-bits of tag into double precision number in <img class="math" src="../_images/math/02b99e25ae92d555c285768eb92a199abd3cf9e2.png" alt="[0, 1]"/>:
tagd.</li>
<li>Compute <img class="math" src="../_images/math/bb03077df62fc2ae47e801aee7e99860c613db00.png" alt="duration = minimumDuration - localMean * log(tagd)"/>.</li>
<li>Set requestTime equal to SGX Trusted Time value.</li>
<li>Create WaitTimer object <img class="math" src="../_images/math/a58d565cd65d47a4fc4abed0f3d2f673351b2f80.png" alt="waitTimer = WaitTimer(requestTime, duration,
WaitCertId_{n}, localMean)"/>.</li>
<li>Compute ECDSA signature of waitTimer using PSK: <img class="math" src="../_images/math/797d666c21dcf5ce85d8e819a781b364cab0bd8e.png" alt="signature =
ECDSA_{PSK} (waitTimer)"/>.</li>
<li>Set global active WaitTimer instance activeWT equal to waitTimer.</li>
<li>Return (waitTimer, signature).</li>
</ol>
</div>
<div class="section" id="createwaitcertificate-blockdigest">
<h3><code class="docutils literal"><span class="pre">createWaitCertificate(blockDigest)</span></code><a class="headerlink" href="#createwaitcertificate-blockdigest" title="Permalink to this headline">¶</a></h3>
<p><strong>Returns</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">WaitCertificate</span> <span class="n">waitCertificate</span>
<span class="n">byte</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="n">signature</span> <span class="c1"># ECDSA PSK signature of waitCertificate</span>
</pre></div>
</div>
<p><strong>Parameters</strong></p>
<div class="code console highlight-default"><div class="highlight"><pre><span></span><span class="n">byte</span><span class="p">[]</span> <span class="n">blockDigest</span> <span class="c1"># ECDSA signature with originator private key of SHA256</span>
                   <span class="c1"># digest of transaction block that the validator wants</span>
                   <span class="c1"># to commit</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<ol class="arabic simple">
<li>If activeWT is equal to NULL, exit.</li>
<li>Read monotonic counter MCID and compare its value to global variable
counterValue. If values do not match, exit.</li>
<li>Read SGX Trusted time into variable currentTime. If currentTime is smaller
than <img class="math" src="../_images/math/34574137acdea69600fb8654893d5ad9d116ef55.png" alt="waitTimer.requestTime + waitTimer.duration"/>, exit (the duration
has not elapsed yet).</li>
<li>If currentTime is larger than <img class="math" src="../_images/math/5478fd7f2f25b89e4f0bfc0f86e0c8719fcfba40.png" alt="waitTimer.requestTime +
waitTimer.duration+T_{WT}"/>, exit.</li>
<li>Generate random nonce.</li>
<li>Create WaitCertificate object <img class="math" src="../_images/math/1105a07ecf1ab43aa9a751759f81016869225f95.png" alt="waitCertificate =
WaitCertificate(waitTimer, nonce, blockDigest)"/>.</li>
<li>Compute ECDSA signature of waitCertificate using PSK: <img class="math" src="../_images/math/8c617992be1db14096e145d76e2ba288311e2ecf.png" alt="signature =
ECDSA_{PSK} (waitCertificate)"/>.</li>
<li>Set activeWT to NULL.</li>
<li>Return (waitCertificate, signature).</li>
</ol>
<div class="section" id="sign-up-phase">
<h4>Sign-up Phase<a class="headerlink" href="#sign-up-phase" title="Permalink to this headline">¶</a></h4>
<p>A participant joins as a validator by downloading the PoET SGX enclave and a
SPID certificate for the block chain. The client side of the validator runs the
following sign-up procedure:</p>
<ol class="arabic">
<li><p class="first">Start PoET SGX enclave: ENC.</p>
</li>
<li><p class="first">Generate sign-up data: <img class="math" src="../_images/math/debf539e7609ceaf5271a449a630ed5318d9f1e7.png" alt="(PPK, report, PSEmanifest, sealedSignUpData) =
\textnormal{ENC.generateSignUpData(OPKhash)}"/> The <code class="docutils literal"><span class="pre">report_data</span></code> (512 bits)
field in the report body includes the SHA256 digest of (OPKhash | PPK).</p>
</li>
<li><p class="first">Ask SGX Quoting Enclave (QE) for linkable quote on the report (using the
validator network&#8217;s Basename).</p>
</li>
<li><p class="first">If Self Attestation is enabled in IAS API: request attestation of linkable
quote and PSE manifest to IAS. The AEP sent to IAS must contain:</p>
<ul class="simple">
<li>isvEnclaveQuote: base64 encoded quote</li>
<li>pseManifest: base64 encoded PSEmanifest</li>
<li>nonce: <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/></li>
</ul>
<p>The IAS sends back a signed AVR containing a copy of the input AEP and the
EPID Pseudonym.</p>
</li>
<li><p class="first">If Self Attestation is enabled in IAS API: broadcast self-attested join
request, (OPK, PPK, AEP, AVR) to known participants.</p>
</li>
<li><p class="first">If Self Attestation is NOT enabled in IAS API: broadcast join request, (OPK,
PPK, quote, PSEmanifest) to known participants.</p>
</li>
</ol>
<p>A validator has to wait for <img class="math" src="../_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"/> block to be published on the distributed
ledger before participating in an election.</p>
<p>The server side of the validator runs the following sign-up procedure:</p>
<ol class="arabic">
<li><p class="first">Wait for a join request.</p>
</li>
<li><p class="first">Upon arrival of a join request do the verification:</p>
<p>If the join request is self attested (Self Attestation is enabled in IAS
API): (OPK, PPK, AEP, AVR)</p>
<ol class="loweralpha simple">
<li>Verify AVR legitimacy using IAS Report Key and therefore quote legitimacy.</li>
<li>Verify the <code class="docutils literal"><span class="pre">report_data</span></code> field within the quote contains the SHA256
digest of (OPKhash | PPK).</li>
<li>Verify the nonce in the AVR is equal to <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/>, namely the
digest of the most recently committed block. It may be that the sender has
not seen <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/> yet and could be sending
<img class="math" src="../_images/math/ecfcd051718d441f846550e7832d53e5b401c912.png" alt="WaitCertId_{n'}"/> where <img class="math" src="../_images/math/50b560ab412a71b504b4dfb91fa83cd34845f35c.png" alt="n'&lt;n"/>. In this case the sender should
be urged to updated his/her view of the ledger by appending the new blocks
and retry. It could also happen that the receiving validator has not seen
<img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/> in which case he/she should try to update his/her
view of the ledger and verify again.</li>
<li>Verify MRENCLAVE value within quote is equal to PoET_MRENCLAVE (there
could be more than one allowed value).</li>
<li>Verify PSE Manifest SHA256 digest in AVR is equal to SHA256 digest of
PSEmanifest in AEP.</li>
<li>Verify basename in the quote is equal to distributed ledger Basename.</li>
<li>Verify attributes field in the quote has the allowed value (normally the
enclave must be in initialized state and not be a debug enclave).</li>
</ol>
<p>If the join request is not self attested (Self Attestation is NOT enabled in
IAS API): (OPK, PPK, quote, PSEmanifest)</p>
<ol class="loweralpha simple">
<li>Create AEP with quote and PSEmanifest :<ul>
<li>isvEnclaveQuote: base64 encoded quote</li>
<li>pseManifest: base64 encoded PSEmanifest</li>
</ul>
</li>
<li>Send AEP to IAS. The IAS sends back a signed AVR.</li>
<li>Verify received AVR attests to validity of both quote and PSEmanifest and
save EPID Pseudonym.</li>
<li>Verify <code class="docutils literal"><span class="pre">report_data</span></code> field within the quote contains the SHA256 digest
of (OPKhash | PPK).</li>
<li>Verify MRENCLAVE value within quote is equal to PoET_MRENCLAVE (there
could be more than one allowed value).</li>
<li>Verify basename in the quote is equal to distributed ledger Basename.</li>
<li>Verify attributes field in the quote has the allowed value (normally the
enclave must be in initialized state and not be a debug enclave).</li>
</ol>
<p>If the verification fails, exit.</p>
<p>If the verification succeeds but the SGX platform identified by the EPID
Pseudonym in the quote has already signed up, ignore the join request, exit.</p>
<p>If the verification succeeds:</p>
<ol class="loweralpha simple">
<li>Pass sign-up certificate of new participant (OPK, EPID Pseudonym, PPK,
current <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/> to upper layers for registration in EndPoint
registry.</li>
<li>Goto 1.</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="election-phase">
<h4>Election Phase<a class="headerlink" href="#election-phase" title="Permalink to this headline">¶</a></h4>
<p>Assume the identifier of the most recent valid block is <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/>.
Broadcast messages are signed by a validator with his/her PPK. To participate in
the election phase a validator runs the following procedure on the client side:</p>
<ol class="arabic simple">
<li>Start the PoET SGX enclave: ENC.</li>
<li>Read the sealedSignUpData from disk and load it into enclave:
<img class="math" src="../_images/math/a85ce230c61ac596719b5bdccc263f2251d7e045.png" alt="ENC.\textnormal{unsealSignUpData}(sealedSignUpData)"/></li>
<li>Call <img class="math" src="../_images/math/c172a13e207b9af9632e11385c82a644af27fb42.png" alt="(waitTimer, signature) = ENC.createWaitTimer(localMean,
WaitCertId_{n})"/>.</li>
<li>Wait waitTimer.duration seconds.</li>
<li>Call <img class="math" src="../_images/math/053dca1c881a5aca29995ffd7d584e20a92a4326.png" alt="(waitCertificate, signature) =
ENC.createWaitCertificate(blockDigest)"/>.</li>
<li>If the <code class="docutils literal"><span class="pre">createWaitCertificate()</span></code> call is successful, broadcast
(waitCertificate, signature, block, OPK, PPK) where block is the transaction
block identified by blockDigest.</li>
</ol>
<p>On the server side a validator waits for incoming (waitCertificate, signature,
block, OPK, PPK) tuples. When one is received the following validity checks are
performed:</p>
<ol class="arabic simple">
<li>Verify the PPK and OPK belong to a registered validator by checking the EndPoint
registry.</li>
<li>Verify the signature is valid using sender&#8217;s PPK.</li>
<li>Verify the PPK was used by sender to commit less than <img class="math" src="../_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"/> blocks by
checking EndPoint registry (otherwise sender needs to re-sign).</li>
<li>Verify the waitCertificate.waitTimer.localMean is correct by comparing against
locaMean computed locally.</li>
<li>Verify the waitCertificate.blockDigest is a valid ECDSA signature of the SHA256
hash of block using OPK.</li>
<li>Verify the sender has been winning elections according to the expected
distribution (see z-test documentation).</li>
<li>Verify the sender signed up at least <img class="math" src="../_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"/> committed blocks ago, i.e.,
respected the <img class="math" src="../_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"/> block start-up delay.</li>
</ol>
<p>A valid waitCertificate is passed to the upper ledger layer and the
waitCertificate with the lowest value of waitCertificate.waitTimer.duration
determines the election winner.</p>
</div>
<div class="section" id="revocation">
<h4>Revocation<a class="headerlink" href="#revocation" title="Permalink to this headline">¶</a></h4>
<p>Two mechanisms are put in place to blacklist validators whose EPID key has been
revoked by IAS. The first one affects each validator periodically, although
infrequently. The second one is an asynchronous revocation check that each
validator could perform on other validators&#8217; EPID keys  at any time.</p>
<ol class="arabic simple">
<li><strong>Periodic regeneration of PPK</strong> a validator whose EPID key has been revoked
by the IAS would not be able to obtain any valid AVR and therefore would be
prevented from signing-up. Forcing validators to periodically re-sign with a
fresh sign-up certificate leaves validators whose EPID keys have been revoked
out of the system. Validators have to re-sign after they commit <img class="math" src="../_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"/>
blocks and if they do not they are considered revoked.</li>
<li><strong>Asynchronous sign-up quote verification</strong> A validator can (at any time) ask
IAS for attestation on a quote that another validator used to sign-up to
check if his/her EPID key has been revoked since. If so the returned AVR will
indicate that the key is revoked. A validator who obtains such an AVR from
IAS can broadcast it in a blacklisting transaction, so that all the
validators can check the veracity of the AVR and proceed with the
blacklisting. To limit the use of blacklisting transactions as a means to
thwart liveness for malicious validators one can control the rate at which
they can be committed in different ways:<ul>
<li>A certain number of participation tokens needs to be burned to commit a
blacklisting transaction.</li>
<li>A validator can commit a blacklisting transaction only once he/she wins one
or more elections.</li>
<li>A validator who commits a certain number of non-legit blacklisting
transactions is blacklisted.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="security-considerations">
<h4>Security Considerations<a class="headerlink" href="#security-considerations" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li><img class="math" src="../_images/math/7b139e757435686e4e7e9c96ba40f18ca544455e.png" alt="T_{WT}"/> <strong>motivation</strong>: A validator has at most <img class="math" src="../_images/math/7b139e757435686e4e7e9c96ba40f18ca544455e.png" alt="T_{WT}"/> seconds
to consume a WaitTimer, namely obtain a WaitCertificate on it after the
WaitTimer itself has expired. This constraint is enforced to avoid that in
case there are no transactions to build a block for some time several
validators might hold back after they waited the duration of their WaitTimers
and generate the WaitCertificate only once enough transactions are available.
At the point they will all send out their WaitCertificates generating a lot
of traffic and possibly inducing forks. The timeout mitigates this problem.</li>
<li><strong>Enclave compromise:</strong> a compromised SGX platform that is able to
arbitrarily win elections cannot affect the correctness of the system, but
can hinder progress by publishing void transactions. This problem is
mitigated by limiting the frequency with which a validator (identified by
his/her PPK) can win elections in a given time frame (see z-test
documentation).</li>
<li><strong>WaitTimer duration manipulation:</strong><ol class="loweralpha">
<li>Imposing a <img class="math" src="../_images/math/ae12a24f88803b5895632e4848d87d46483c492c.png" alt="c"/> block participation delay after sign-up prevents
validators from generating different pairs of OPK, PPK and pick the one that
would result in the lowest value of the next WaitTimer duration as follows:<ol class="lowerroman">
<li>Generate as many PPK,PSK pairs and therefore monotonic counters as
possible.</li>
<li>Do not sign up but use all the enclaves (each using a different PPK,
PSK and MCID) to create a WaitTimer every time a new block is committed
until a very low duration is obtained (good chance of winning the
election). Then collect all the different waitCertIds.</li>
<li>Ask each enclave to create the next waitTimer, whose duration depends
on each of the different winning waitCertIds. Choose the PPK of the
enclave giving me the lowest next duration and sign up with that.</li>
<li>As a result an attacker can win the first the election (with high
probability) and can chain the above 3 steps to get a good chance of
winning several elections in a row.</li>
</ol>
</li>
<li>The nonce field in WaitCertificate is set to a random value so that a
validator does not have control over the resulting <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/>.
A validator winning an election could otherwise try different blockDigest
input values to createWaitCertificate and broadcast the WaitCertificate
whose <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/> results in the lowest duration of his/her
next WaitTimer.</li>
<li>The call <code class="docutils literal"><span class="pre">createWaitTimer()</span></code> in step 1 of the election phase (client
side) is bound to the subsequent call to <code class="docutils literal"><span class="pre">createWaitCertificate()</span></code> by
the internal state of the PoET enclave. More precisely only one call to
<code class="docutils literal"><span class="pre">createWaitCertificate()</span></code> is allowed after a call to
<code class="docutils literal"><span class="pre">createWaitTimer()</span></code> (and the duration has elapsed) as the value of the
global active WaitTimer object activeWT is set to null at the end of
<code class="docutils literal"><span class="pre">createWaitCertificate()</span></code> so that subsequent calls would fail. Therefore
only one transaction block (identified by the input parameter blockDigest)
can be attached to a WaitCertificate object. This prevents a malicious
user from creating multiple WaitCertificates (each with a different nonce)
resulting in different WaitCertId digests without re-creating a WaitTimer
(and waiting for its duration) each time. It follows that as long as the
duration of WaitTimer is not too small a malicious validator who wins the
current election has very limited control over the duration of his/hers
next WaitTimer.</li>
<li>The check on the Monotonic Counter value guarantees only one enclave
instance can obtain a WaitCertificate after the WaitTimer duration
elapses. This again prevents a malicious user from running multiple
instances of the enclave to create multiple WaitCertificates (each with a
different nonce) resulting in different WaitCertId digests and selecting
the one that would result in the lowest duration for a new WaitTimer.</li>
<li>A monotonic counter with id MCID is created at the same time PPK and PSK
are generated and the triple (MCID, PPK, PSK) is encrypted using AES-GCM
with the Seal Key and saved in permanent storage. A malicious validator
cannot run multiple enclave instances (before signing up) to create
multiple monotonic counters without being forced to commit to using only
one eventually. As a monotonic counter is bound to PPK, PSK through the
AES-GCM encryption with the Seal Key, when a validator signs-up with a PPK
it automatically commits to using the monotonic counter that was create
along with PPK, PSK.</li>
</ol>
</li>
<li><strong>Sign-up AEP replay:</strong> the use of the nonce field in the AEP, which is set
equal to <img class="math" src="../_images/math/c66c902102ade6288047eb8a5c55ec02eaefed1e.png" alt="WaitCertId_{n}"/>, is used to prevent the replay of old AEPs.</li>
</ol>
</div>
<div class="section" id="comments-on-multi-user-or-multi-ledger-sgx-enclave-service">
<h4>Comments on multi-user or multi-ledger SGX enclave service<a class="headerlink" href="#comments-on-multi-user-or-multi-ledger-sgx-enclave-service" title="Permalink to this headline">¶</a></h4>
<p>It is possible to use the same enclave for multiple users or ledgers by making
username and ledgername input <strong>Parameters</strong> to <code class="docutils literal"><span class="pre">generateSignUpData()</span></code> and
<code class="docutils literal"><span class="pre">unsealSignUpData()</span></code>. Then the sign-up tuple (username, ledgername, PPK, PSK,
MCID) is sealed to disk, with username and ledgername used to generate the
filename. Anytime a user authenticates to the service the latter can have the
enclave unseal and use the sign-up tuple from the file corresponding to that
user (and ledger).</p>
</div>
</div>
</div>
<div class="section" id="population-size-and-local-mean-computation">
<h2>Population Size and Local Mean Computation<a class="headerlink" href="#population-size-and-local-mean-computation" title="Permalink to this headline">¶</a></h2>
<p><strong>Parameters</strong>:</p>
<ol class="arabic simple">
<li>targetWaitTime: the desired average wait time. This depends on the network
diameter and is selected to minimize the probability of a collision.</li>
<li>initialWaitTime: the initial wait time used in the bootstrapping phase until
the ledger contains sampleLength blocks.</li>
<li>sampleLength: number of blocks that need to be on the ledger to finish the
bootstrapping phase and get into the steady phase.</li>
<li>minimumWaitTime: a lower bound on the wait time.</li>
</ol>
<p>The population size is computed as follows:</p>
<ol class="arabic simple">
<li><img class="math" src="../_images/math/e4fbaea3600a082237aeefe3ccc3f3a81cd97d63.png" alt="sm=0"/></li>
<li><img class="math" src="../_images/math/8b41a1543cfb95c76b693aec311cf1f162a03447.png" alt="sw=0"/></li>
<li><strong>foreach</strong> wait certificate <img class="math" src="../_images/math/e947cdd85cac1c4e5a869eaf9055dae6d5679907.png" alt="wc"/> stored on the ledger:
* <img class="math" src="../_images/math/496bbb779177f54ec44684c53fdcd6de80589597.png" alt="sw=sw+wc\textrm{.waitTimer.duration}-\textrm{minimumWaitTime}"/>
* <img class="math" src="../_images/math/ec2f1126a69b2b356b5590f7a73f296f96f1ecfa.png" alt="sm=sm+wc\textrm{.waitTimer.localMean}"/></li>
<li><img class="math" src="../_images/math/ff89e2d4db3a4595e65938fd0ed7d8903d95d50a.png" alt="populationSize=sm/sw"/></li>
</ol>
<p>Assuming <img class="math" src="../_images/math/57c9d14bb082716df9000146882ce365335d08f1.png" alt="b"/> is the number of blocks currently stored on the ledger the
local mean is computed as follows:</p>
<ol class="arabic simple">
<li>if <img class="math" src="../_images/math/578180fecb0e15c9f8153e19a6b4a57a17ffd192.png" alt="b &lt; \textrm{sampleLength}"/> then <img class="math" src="../_images/math/68ed10b2b9da3db0dd113078703dd214c7962abf.png" alt="r = 1.0\cdot b /
\textrm{sampleLength}"/> and <img class="math" src="../_images/math/7be72f3af5619532aa0f64c576eb868f3a2280fb.png" alt="\textrm{localMean} =
\textrm{targetWaitTime}\cdot (1 - r^2) + \textrm{initialWaitTime}\cdot r^2"/>.</li>
<li>else <img class="math" src="../_images/math/3ae700388e8c1c87bcc4276c7ac4b02b712cd774.png" alt="\textrm{localMean}= \textrm{targetWaitTime}\cdot
\textrm{populationSize}"/></li>
</ol>
</div>
<div class="section" id="z-test">
<h2>z-test<a class="headerlink" href="#z-test" title="Permalink to this headline">¶</a></h2>
<p>A z-test is used to test the hypothesis that a validator won elections at a
higher average rate than expected. <strong>Parameters</strong>:</p>
<p>1. zmax: test value, it measures the deviation from the expected mean. It is
selected so that the desired confidence interval $alpha$ is obtained. Example
configurations are:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><img class="math" src="../_images/math/e7981d302fd2c07e5fee0324a9ad71eba5d6ffc2.png" alt="\textrm{ztest}=1.645 \leftrightarrow \alpha=0.05"/></li>
<li><img class="math" src="../_images/math/b88a4b5ef3948e734d05a442a9a47fdf36397fc2.png" alt="\textrm{ztest}=2.325 \rightarrow \alpha=0.01"/></li>
<li><img class="math" src="../_images/math/51c48cd0b0b5fbe9db9c5520c1bca100563af138.png" alt="\textrm{ztest}=2.575 \rightarrow \alpha=0.005"/></li>
<li><img class="math" src="../_images/math/f07070e3b2370a1df11c98c9b10edd53d81d1691.png" alt="\textrm{ztest}=3.075 \rightarrow \alpha=0.001"/></li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>testIdentifier: the validator identifier under test.</li>
<li>blockArray: an array containing pairs of validator identity and estimated
population size: <img class="math" src="../_images/math/c1e706be56591a9eba9ebdea45ec0eedb1d0bc28.png" alt="(\textit{id},  \textit{populationEstimate})"/>. Each
pair represents one published transaction block.</li>
<li>minObserved: minimum number of election wins that needs to be observed for
the identifier under test.</li>
</ol>
<p>The z-test is computed as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">observed</span> <span class="o">=</span> <span class="n">expected</span> <span class="o">=</span> <span class="n">blockCount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">foreach</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">populationEstimate</span><span class="p">)</span> <span class="ow">in</span> <span class="n">blockArray</span><span class="p">:</span>
    <span class="n">blockCount</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">expected</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">populationEstimate</span>

    <span class="k">if</span> <span class="nb">id</span> <span class="ow">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">testIdentifier</span><span class="p">:</span>
        <span class="n">observed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">observed</span> <span class="o">&gt;</span> <span class="n">minObserved</span> <span class="ow">and</span> <span class="n">observed</span> <span class="o">&gt;</span> <span class="n">expected</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">expected</span> <span class="o">/</span> <span class="n">blockCount</span>
            <span class="n">σ</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">blockCount</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">))</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">observed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span> <span class="o">/</span> <span class="n">σ</span>
            <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">zmax</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
<span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
<p>If the z-test fails (False is returned) then the validator under test won
elections at a higher average rate than expected.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="validator_network.html" class="btn btn-neutral float-right" title="Validator Network" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rest_api.html" class="btn btn-neutral" title="REST API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Intel Corporation.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'v0.8.12',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>