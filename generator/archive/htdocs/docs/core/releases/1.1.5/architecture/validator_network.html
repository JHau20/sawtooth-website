

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Validator Network &mdash; Sawtooth v1.1.5 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Permissioning Design" href="permissioning_requirement.html" />
    <link rel="prev" title="REST API" href="rest_api.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../contents.html" class="icon icon-home"> Sawtooth
          

          
          </a>

          
            
            
              <div class="version">
                v1.1.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../app_developers_guide.html">Application Developer’s Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../architecture.html">Architecture Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="global_state.html">Global State</a></li>
<li class="toctree-l2"><a class="reference internal" href="transactions_and_batches.html">Transactions and Batches</a></li>
<li class="toctree-l2"><a class="reference internal" href="journal.html">Journal</a></li>
<li class="toctree-l2"><a class="reference internal" href="scheduling.html">Transaction Scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="rest_api.html">REST API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Validator Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#services">Services</a></li>
<li class="toctree-l3"><a class="reference internal" href="#states">States</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wire-protocol">Wire Protocol</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#message-types">Message Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transmission-methods">Transmission Methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#peer-discovery">Peer Discovery</a></li>
<li class="toctree-l3"><a class="reference internal" href="#message-delivery">Message Delivery</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network-layer-security">Network Layer Security</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network-permissioning">Network Permissioning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#authorization-types">Authorization Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#authorization-violation">Authorization Violation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="permissioning_requirement.html">Permissioning Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="injecting_batches_block_validation_rules.html">Injecting Batches and On-Chain Block Validation Rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="events_and_transactions_receipts.html">Events and Transaction Receipts</a></li>
<li class="toctree-l2"><a class="reference internal" href="poet.html">PoET 1.0 Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../transaction_family_specifications.html">Transaction Family Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sysadmin_guide.html">System Administrator’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_references.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cli.html">CLI Command Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">Sawtooth</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="../architecture.html">Architecture Guide</a> &raquo;</li>
        
      <li>Validator Network</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/architecture/validator_network.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="validator-network">
<h1>Validator Network<a class="headerlink" href="#validator-network" title="Permalink to this headline">¶</a></h1>
<p>The network layer is responsible for communication between validators in a
Sawtooth network, including performing initial connectivity, peer discovery,
and message handling. Upon startup, validator instances begin listening on a
specified interface and port for incoming connections. Upon connection and
peering, validators exchange messages with each other based on the rules of a
<a class="reference external" href="http://disi.unitn.it/~montreso/ds/papers/montresor17.pdf">gossip or epidemic protocol</a>
(also see <a class="reference external" href="https://en.wikipedia.org/wiki/Gossip_protocol">Gossip protocol on Wikipedia</a>).</p>
<p>A primary design goal is to keep the network layer as self-contained as
possible. For example, the network layer should not need knowledge of the
payload of application messages, nor should it need application-layer provided
data to connect to peers or to build out the connectivity of the network.
Conversely, the application should not need to understand implementation
details of the network in order to send and receive messages.</p>
<div class="section" id="services">
<h2>Services<a class="headerlink" href="#services" title="Permalink to this headline">¶</a></h2>
<p>The choice of <a class="reference external" href="http://zeromq.org">0MQ</a> provides considerable
flexibility in both the available
connectivity patterns and the underlying capabilities of the transport layer
(IPv4, IPv6, etc.)</p>
<p>Sawtooth has adopted the
<a class="reference external" href="http://zguide.zeromq.org/php:chapter3#toc24">0MQ asynchronous client/server pattern</a>,
which consists
of a 0MQ ROUTER socket on the server side which listens on a provided
endpoint, with a number of connected 0MQ DEALER sockets as the connected
clients. The 0MQ guide describes the features of this pattern as follows:</p>
<ul class="simple">
<li><p>Clients connect to the server and send requests.</p></li>
<li><p>For each request, the server sends 0 or more replies.</p></li>
<li><p>Clients can send multiple requests without waiting for a reply.</p></li>
<li><p>Servers can send multiple replies without waiting for new requests.</p></li>
</ul>
<div class="figure align-center" id="id2">
<a class="reference internal image-reference" href="../_images/multiple_dealer_to_router.svg"><img alt="Multiple dealer to router diagram" src="../_images/multiple_dealer_to_router.svg" width="50%" /></a>
<p class="caption"><span class="caption-text">Multiple DEALER to ROUTER socket pattern</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="states">
<h2>States<a class="headerlink" href="#states" title="Permalink to this headline">¶</a></h2>
<p>Sawtooth defines three states related to the connection between any two
validator nodes:</p>
<ul class="simple">
<li><p>Unconnected</p></li>
<li><p>Connected - A connection is a required prerequisite for peering.</p></li>
<li><p>Peered - A bidirectional relationship that forms the base case for
application-level message passing (gossip).</p></li>
</ul>
</div>
<div class="section" id="wire-protocol">
<h2>Wire Protocol<a class="headerlink" href="#wire-protocol" title="Permalink to this headline">¶</a></h2>
<p>Sawtooth has standardized on protobuf serialization for any structured messages
that need to be passed over the network. All payloads to or from the application
layer are treated as opaque.</p>
<div class="section" id="message-types">
<h3>Message Types<a class="headerlink" href="#message-types" title="Permalink to this headline">¶</a></h3>
<p>This protocol includes the following types of messages:</p>
<p>CONNECT</p>
<p>Connect is the mechanism for initiating the connection to the remote node.
Connect performs a basic 0MQ DEALER-to-ROUTER connection to the remote node and
exchanges identity information for the purpose of supporting a two-way
conversation. Connections sit atop 0MQ sockets and allow the DEALER/ROUTER
conversation.</p>
<p>PING</p>
<p>Ping messages allow for keep-alive between ROUTER and DEALER sockets.</p>
<p>PEER</p>
<p>Peer requests establish a bidirectional peering relationship between the two
nodes. A peer request can be rejected by the remote node. If a peer request is
rejected, the expectation is that a node attempts to connect with other
nodes in the network via some strategy until the peering minimum connectivity
threshold for that node is reached. If possible, the bi-directional
relationship occurs over the already established 0MQ socket between
DEALER and ROUTER.</p>
<p>GET_PEERS</p>
<p>A get_peers message returns a list of peers of a given node. This can be
performed in a basic connected state; it does not require peering to have
occurred. The intent is to
allow a node attempting to reach its minimum connectivity peering threshold to
build a view of active candidate peers via a neighbor-of-neighbors approach.</p>
<p>UNPEER</p>
<p>An unpeer message breaks the peering relationship between nodes. This may
occur in several scenarios, such as a node leaving the network. (Nodes may
also silently leave the network, in which case their departure will be
detected by the failure of the ping/keep-alive message.) An unpeer request
does not necessarily imply a disconnect.</p>
<p>DISCONNECT</p>
<p>A disconnect message breaks the wire protocol connection to the remote node
and informs the ROUTER end to clean up the connection.</p>
</div>
<div class="section" id="transmission-methods">
<h3>Transmission Methods<a class="headerlink" href="#transmission-methods" title="Permalink to this headline">¶</a></h3>
<p>Transmission methods include the following:</p>
<p>BROADCAST(MSG)</p>
<p>Broadcast transmits an application message to the network following a
“gossipy” pattern.
This does not guarantee 100% delivery of the message to the whole network, but
based on the gossip parameters, nearly complete delivery is likely. A node
only accepts messages for broadcast/forwarding from peers.</p>
<p>SEND(NODE, MSG)</p>
<p>Send attempts to send a message to a particular node over the bidirectional 0MQ
connection. Delivery is not guaranteed. If a node has reason to believe that
delivery to the destination node is impossible, it can return an error response.
A node only accepts a message for sending from peer nodes.</p>
<p>REQUEST(MSG)</p>
<p>A request is a special type of broadcast message that can be examined and
replied to, rather than forwarded. The intent is for the application layer to
construct a message payload which can be examined by a special request handler
and replied to, rather than forwarded on to connected peers. If the application
layer reports that the request can’t be satisfied, the message will be
forwarded to peers per the rules of a standard broadcast message. A node
only accepts request messages from peer nodes.</p>
</div>
</div>
<div class="section" id="peer-discovery">
<h2>Peer Discovery<a class="headerlink" href="#peer-discovery" title="Permalink to this headline">¶</a></h2>
<p>A bidirectional peering via a neighbor-of-neighbors approach gives reliable
connectivity (messages delivered to all nodes &gt; 99% of the time based on random
construction of the network).</p>
<p>Peer connections are established by collecting a suitable population of
candidate peers through successive CONNECT/GET_PEERS calls
(neighbors of neighbors). The connecting validator then selects a candidate
peer randomly from the list and attempts to connect and peer with it. If this
succeeds, and the connecting validator has reached minimum connectivity, the
process halts. If minimum connectivity has not yet been reached, the validator
continues attempting to connect to new candidate peers, refreshing its view of
the neighbors of neighbors if it exhausts candidates.</p>
<div class="figure align-center" id="id3">
<a class="reference internal image-reference" href="../_images/bidirectional_peering.svg"><img alt="Output of bidirectional peering with targeted connectivity of 4." src="../_images/bidirectional_peering.svg" width="75%" /></a>
<p class="caption"><span class="caption-text">Output of bidirectional peering with targeted connectivity of 4.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>The network component continues to perform a peer search if its number of
peers is less than the minimum connectivity. The network component rejects
peering attempts if its number of peers is equal to or greater than the maximum
connectivity. Even if maximum peer connections is reached, a network service
should still accept and respond to a reasonable number of connections (for the
purposes of other node topology build outs, etc.)</p>
</div>
<div class="section" id="message-delivery">
<h2>Message Delivery<a class="headerlink" href="#message-delivery" title="Permalink to this headline">¶</a></h2>
<p>The network delivers application messages (payloads received via BROADCAST
or SEND) to the application layer. The network also performs a basic
validation of messages prior to forwarding by calling a handler in the Message
Validation component.</p>
<p>When the network receives a REQUEST message, it calls a provided handler
(a “Responder”, for example) to determine if the request can be
satisfied. If so, the expectation is that the application layer generates a
SEND message with a response that satisfies the request. In this condition, the
network layer does not continue to propagate the REQUEST message to the network.</p>
<p>In the case where a node could not satisfy the request, the node stores who
it received the request from and BROADCASTs the request on to its peers. If that
node receives a SEND message with the response to the request, it forwards
the SEND message back to the original requester.</p>
<p>The network accepts application payloads for BROADCAST, SEND, and REQUEST
from the application layer.</p>
</div>
<div class="section" id="network-layer-security">
<h2>Network Layer Security<a class="headerlink" href="#network-layer-security" title="Permalink to this headline">¶</a></h2>
<p>0MQ includes a
<a class="reference external" href="https://github.com/zeromq/pyzmq/blob/master/examples/security/ironhouse.py">TLS-like</a>
certificate exchange mechanism and protocol
encryption capability that is transparent to the socket implementation.
Support for socket-level encryption is currently implemented with server keys,
which are read from the <code class="docutils literal notranslate"><span class="pre">validator.toml</span></code> configuration file. For each client,
ephemeral certificates are generated on connect. If the server key pair is not
configured, network communications between validators will not be authenticated
or encrypted.</p>
</div>
<div class="section" id="network-permissioning">
<h2>Network Permissioning<a class="headerlink" href="#network-permissioning" title="Permalink to this headline">¶</a></h2>
<p>The Sawtooth
<a class="reference internal" href="permissioning_requirement.html"><span class="doc">permissioning design</span></a>
allows the validator network to
limit the nodes that are able to connect to it. The permissioning rules
determine the roles a connection is able to play on the network. The roles
control the types of messages that can be sent and received over a given
connection. The components and nodes that wish to take on these roles must
participate in an authorization “handshake” and request the roles they want to
take on. The entities acting in the different roles will be referred to as
requesters below.</p>
<p>Validators are able to determine whether messages delivered to them should
be handled or dropped based on a set of role and identities stored within the
Identity namespace. Each requester will be identified by the public key derived
from their identity signing key. Permission verifiers examine incoming
messages against the policy and the current configuration and either permit,
drop, or respond with an error. In certain cases, the connection will be
forcibly closed – for example, if a node is not allowed to connect to the
validator network.</p>
<p>The following describes the procedure for establishing a new connection with
the validator. The procedure supports implementing different authorization
types that require the requester to prove their identity. If a requester
deviates from the procedure in any way, the requester will be rejected and the
connection will be closed. The same is true if the requester sends multiple
<code class="docutils literal notranslate"><span class="pre">ConnectionRequest</span></code> messages or a multiple of any authorization-type message.
Certain low-level messages, such as ping,
can be used before the procedure is complete, but
these messages are rate-limited. If too many low-level messages are received or
if they are received too close together, the connection may be considered
malicious, so it will be rejected.</p>
<p>The validator receiving a new connection receives a <code class="docutils literal notranslate"><span class="pre">ConnectionRequest</span></code>.
The validator responds with a <code class="docutils literal notranslate"><span class="pre">ConnectionResponse</span></code> message. The
<code class="docutils literal notranslate"><span class="pre">ConnectionResponse</span></code> message contains a list of <code class="docutils literal notranslate"><span class="pre">RoleEntry</span></code> messages and an
<code class="docutils literal notranslate"><span class="pre">AuthorizationType</span></code>. Role entries are the accepted type of connections that
are supported on the endpoint that the <code class="docutils literal notranslate"><span class="pre">ConnectionRequest</span></code> was sent to.
<code class="docutils literal notranslate"><span class="pre">AuthorizationType</span></code> describes the procedure required to gain access to that
role.  Trust is the simplest authorization type and must be implemented by all
requesters at a minimum. If the requester cannot comply with the given
authorization type for that role entry, it is unable to gain access to that
role.</p>
<div class="highlight-protobuf notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">ConnectionRequest</span> <span class="p">{</span>
  <span class="c1">// This is the first message that must be sent to start off authorization.</span>
  <span class="c1">// The endpoint of the connection.</span>
  <span class="kt">string</span> <span class="na">endpoint</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="n">RoleType</span> <span class="p">{</span>
  <span class="c1">// A shorthand request for asking for all allowed roles.</span>
  <span class="na">ALL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Role defining validator to validator communication</span>
  <span class="na">NETWORK</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">ConnectionResponse</span> <span class="p">{</span>
  <span class="c1">// Whether the connection can participate in authorization</span>
  <span class="kd">enum</span> <span class="n">Status</span> <span class="p">{</span>
    <span class="na">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">ERROR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//Authorization Type required for the authorization procedure</span>
  <span class="kd">enum</span> <span class="n">AuthorizationType</span> <span class="p">{</span>
    <span class="na">TRUST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">CHALLENGE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">message</span> <span class="nc">RoleEntry</span> <span class="p">{</span>
    <span class="c1">// The role type for this role entry</span>
    <span class="n">RoleType</span> <span class="na">role</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// The Authorization Type required for the above role</span>
    <span class="n">AuthorizationType</span> <span class="na">auth_type</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">repeated</span> <span class="n">RoleEntry</span> <span class="na">roles</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">Status</span> <span class="na">status</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="authorization-types">
<span id="id1"></span><h3>Authorization Types<a class="headerlink" href="#authorization-types" title="Permalink to this headline">¶</a></h3>
<p>Sawtooth implements two authorization types: trust and challenge.</p>
<div class="section" id="trust-authorization">
<h4>Trust Authorization<a class="headerlink" href="#trust-authorization" title="Permalink to this headline">¶</a></h4>
<p>Trust is the simplest authorization type. If trust authorization is
enabled, the validator will trust the connection and approve any roles
requested that are available on that endpoint. If the requester wishes to gain
access to every role it has permission to access, it can request access to the
role <code class="docutils literal notranslate"><span class="pre">ALL</span></code>, and the validator will respond with all available roles.
However, if a role that is not available is requested, the requester is
rejected and the connection will be closed.</p>
<blockquote>
<div><div class="highlight-protobuf notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">AuthorizationTrustRequest</span> <span class="p">{</span>
  <span class="c1">// A set of requested RoleTypes</span>
  <span class="k">repeated</span> <span class="n">RoleType</span> <span class="na">roles</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">public_key</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">AuthorizationTrustResponse</span> <span class="p">{</span>
  <span class="c1">// The actual set the requester has access to</span>
  <span class="k">repeated</span> <span class="n">RoleType</span> <span class="na">roles</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>This diagram shows the message flow for trust authorization.</p>
<blockquote>
<div><a class="reference internal image-reference" href="../_images/trust_authorization.svg"><div align="center" class="align-center"><img alt="Trust Authorization Flow" src="../_images/trust_authorization.svg" width="80%" /></div>
</a>
</div></blockquote>
</div>
<div class="section" id="challenge-authorization">
<h4>Challenge Authorization<a class="headerlink" href="#challenge-authorization" title="Permalink to this headline">¶</a></h4>
<p>If the connection wants to take on a role that requires a challenge to be
signed, it will request the challenge by sending the following message to the
validator that it wishes to connect to.</p>
<blockquote>
<div><div class="highlight-protobuf notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">AuthorizationChallengeRequest</span> <span class="p">{</span>
  <span class="c1">// Empty message sent to request a payload to sign</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The validator will send back a random payload that must be signed.</p>
<blockquote>
<div><div class="highlight-protobuf notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">AuthorizationChallengeResponse</span> <span class="p">{</span>
  <span class="c1">// Random payload that the connecting node must sign</span>
  <span class="kt">bytes</span> <span class="na">payload</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The requester then signs the payload message and returns a response that
includes the following:</p>
<blockquote>
<div><div class="highlight-protobuf notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">AuthorizationChallengeSubmit</span> <span class="p">{</span>
  <span class="c1">// public key of node</span>
  <span class="kt">string</span> <span class="na">public_key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// signature derived from signing the challenge payload</span>
  <span class="kt">string</span> <span class="na">signature</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="c1">// A set of requested Roles</span>
  <span class="k">repeated</span> <span class="n">RoleType</span> <span class="na">roles</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The requester may also request <code class="docutils literal notranslate"><span class="pre">ALL</span></code>. The validator will respond with a
status that says whether the challenge was accepted and the roles that the
connection is allowed take on.</p>
<blockquote>
<div><div class="highlight-protobuf notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">AuthorizationChallengeResult</span> <span class="p">{</span>
  <span class="c1">// The approved roles for that connection</span>
  <span class="k">repeated</span> <span class="n">RoleType</span> <span class="na">roles</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The following diagram shows the message flow for challenge authorization:</p>
<blockquote>
<div><a class="reference internal image-reference" href="../_images/challenge_authorization.svg"><div align="center" class="align-center"><img alt="Challenge Authorization Flow" src="../_images/challenge_authorization.svg" width="80%" /></div>
</a>
</div></blockquote>
<p>When the validator receives an <code class="docutils literal notranslate"><span class="pre">AuthorizationChallengeSubmit</span></code> message, it
verifies the public key against the signature. If the public key is verified,
the requested roles is checked against the stored roles to see if the
public key is included in the policy. If the node’s response is accepted, the
node’s public key is stored and the requester may start sending messages
for the approved roles.</p>
<p>If the requester wanted a role that is either not available on the endpoint
or the requester does not have access to one of the roles requested, the
challenge will be rejected and the connection is closed. At that point
the requester will need to restart the connection process.</p>
</div>
</div>
<div class="section" id="authorization-violation">
<h3>Authorization Violation<a class="headerlink" href="#authorization-violation" title="Permalink to this headline">¶</a></h3>
<p>If, at any time, a requester tries to send a message that is against its
allowed permission, the validator responds with an <code class="docutils literal notranslate"><span class="pre">AuthorizationViolation</span></code>
message and the connection is closed. If that requester wishes to rejoin
the network, it will need to go back through the connection and authorization
process described above.</p>
<blockquote>
<div><div class="highlight-protobuf notranslate"><div class="highlight"><pre><span></span><span class="kd">message</span> <span class="nc">AuthorizationViolation</span> <span class="p">{</span>
  <span class="c1">// The Role the requester did not have access to</span>
  <span class="n">RoleType</span> <span class="na">violation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="permissioning_requirement.html" class="btn btn-neutral float-right" title="Permissioning Design" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rest_api.html" class="btn btn-neutral float-left" title="REST API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Intel Corporation

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>